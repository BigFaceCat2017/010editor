//--------------------------------------
//--- 010 Editor v6.0.1 Binary Template
//
// File: OVLTemplate.bt
// Author: Andrew McRae
// Revision: 0.1
// Purpose: Parse Elite Dangerous ovl files
//--------------------------------------

typedef uint64 u8;
typedef uint32 u4;
typedef uint16 u2;
typedef ubyte  u1;
typedef int64  s8;
typedef int32  s4;
typedef int16  s2;
typedef byte   s1;


typedef struct {
    char sig[4];

    u4 unknown04 <bgcolor=0xd8d8d8>;
    u4 unknown08 <bgcolor=0xd8d8d8>;
    u4 unknown0C <bgcolor=0xd8d8d8>;

    u4 names_length;

    u4 zero14 <bgcolor=0xd8d8d8>;

    u4 other_count <format=decimal>;
    u2 dir_count <format=decimal>;
    u2 type_count <format=decimal>;
    u4 file_count <format=decimal>;
    u4 file_count2 <format=decimal>;
    u4 part_count <format=decimal>;
    u4 archive_count <format=decimal>;

    u4 unknown30 <bgcolor=0xd8d8d8>;
    u4 unknown34 <bgcolor=0xd8d8d8>;
    u4 unknown38 <bgcolor=0xd8d8d8>;
    u4 unknown3C <bgcolor=0xd8d8d8>;
    u4 zero40 <bgcolor=0xd8d8d8>;
    u4 unknown44 <bgcolor=0xd8d8d8>;
    u4 unknown48 <bgcolor=0xd8d8d8>;
    u4 unknown4C <bgcolor=0xd8d8d8>;

    u4 archive_names_length;
    u4 file_count3 <format=decimal>;
    u4 type_names_length;

    u4 zero5C <bgcolor=0xd8d8d8>;

    u4 zero60 <hidden=true,bgcolor=cNone>;
    u4 zero64 <hidden=true,bgcolor=cNone>;
    u4 zero68 <hidden=true,bgcolor=cNone>;
    u4 zero6C <hidden=true,bgcolor=cNone>;
    u4 zero70 <hidden=true,bgcolor=cNone>;
    u4 zero74 <hidden=true,bgcolor=cNone>;
    u4 zero78 <hidden=true,bgcolor=cNone>;
    u4 zero7C <hidden=true,bgcolor=cNone>;
    u4 zero80 <hidden=true,bgcolor=cNone>;
    u4 zero84 <hidden=true,bgcolor=cNone>;
    u4 zero88 <hidden=true,bgcolor=cNone>;
    u4 zero8C <hidden=true,bgcolor=cNone>;

    Assert(file_count2 == file_count, "HEADER file_count2 mismatch");
    Assert(file_count3 == file_count, "HEADER file_count3 mismatch");
    Assert((file_count == 0) || (type_names_length > 0), "HEADER type_names_length is 0");
    Assert((file_count == 0) || (names_length > 0), "HEADER names_length is 0");
    Assert((archive_count == 0) || (archive_names_length > 0), "HEADER archive_names_length is 0");
    //Assert(dir_count == 0, "HEADER dir_count not 0");
    //Assert(part_count == 0, "HEADER part_count not 0");
    //Assert(other_count == 0, "HEADER other_count not 0");
    //Assert(!(dir_count != 0 && part_count != 0), "HEADER dir and part");
    Assert(!(dir_count != 0 && other_count != 0), "HEADER dir and other");
    Assert(!(part_count != 0 && other_count != 0), "HEADER part and other");
    Assert(archive_count == 1, "HEADER archive_count not 1");

    Assert(unknown04 == 0x01001200, "HEADER unknown04 not 0x01001200");
    Assert(unknown08 == 0x00006094, "HEADER unknown08 not 0x00006094");
    Assert(unknown0C == 0x00000000, "HEADER unknown0C not 0x00000000");

    Assert(zero14 == 0, "HEADER zero14");
    Assert(zero40 == 0, "HEADER zero40");
    Assert(zero5C == 0, "HEADER zero5C");

    Assert(zero60 == 0, "HEADER zero60");
    Assert(zero64 == 0, "HEADER zero64");
    Assert(zero68 == 0, "HEADER zero68");
    Assert(zero6C == 0, "HEADER zero6C");
    Assert(zero70 == 0, "HEADER zero70");
    Assert(zero74 == 0, "HEADER zero74");
    Assert(zero78 == 0, "HEADER zero78");
    Assert(zero7C == 0, "HEADER zero7C");
    Assert(zero80 == 0, "HEADER zero70");
    Assert(zero84 == 0, "HEADER zero74");
    Assert(zero88 == 0, "HEADER zero78");
    Assert(zero8C == 0, "HEADER zero7C");
} HEADER;

typedef struct {
    u4 name_offset;
    u4 hash;

    u4 unknown08 <bgcolor=0xffd8d8>;
    u4 unknown0C <bgcolor=0xffd8d8>;
    u4 unknown10 <bgcolor=0xffd8d8>;

    Assert(name_offset < h.names_length, "TYPE name_offset too high");

    local quad o = FTell();
    FSeek(name_offset + full_names_offset);

    string name <bgcolor=0xff6060>;

    FSeek(o);
} TYPE <optimize=false,read=read_TYPE>;
string read_TYPE(TYPE &in) {
    string out;
    SPrintf(out, "\"%s\" 0x%08x 0x%x 0x%x 0x%x", in.name, in.hash, in.unknown08, in.unknown0C, in.unknown10);
    return out;
}

typedef struct {
    TYPE t[h.type_count];
} TYPES <read=read_TYPES>;
string read_TYPES(TYPES &in) {
    string out;
    SPrintf(out, "%u", h.type_count);
    return out;
}

typedef struct {
    u4 name_offset;
    u4 hash;

    u2 unknown08 <bgcolor=0xd8ffd8>;

    u2 type <format=decimal>;

    Assert(type < h.type_count, "FILE type too high");
    Assert(name_offset < h.names_length, "FILE name_offset too high");

    local quad o = FTell();
    FSeek(name_offset + full_names_offset);

    string name <bgcolor=0x60ff60>;

    FSeek(o);
} FILE <optimize=false,read=read_FILE>;
string read_FILE(FILE &in) {
    string out;
    SPrintf(out, "\"%s\" \"%s\" 0x%08x 0x%x", in.name, t.t[in.type].name, in.hash, in.unknown08);
    return out;
}

typedef struct {
    FILE f[h.file_count];
} FILES <read=read_FILES>;
string read_FILES(FILES &in) {
    string out;
    SPrintf(out, "%u", h.file_count);
    return out;
}

typedef struct {
    string type <bgcolor=0x6060ff>;

    Assert(type == "STATIC", "ARCHIVE type not STATIC");
    u1 zero06 <bgcolor=0xd8d8ff>;

    u4 zero08 <bgcolor=0xd8d8ff>;
    u4 zero0C <bgcolor=0xd8d8ff>;
    u4 zero10 <bgcolor=0xd8d8ff>;
    u4 unknown14 <bgcolor=0xd8d8ff>;
    u4 unknown18 <bgcolor=0xd8d8ff>;
    u4 zero1C <bgcolor=0xd8d8ff>;
    u4 unknown20 <bgcolor=0xd8d8ff>;
    u4 unknown24 <bgcolor=0xd8d8ff>;
    u4 unknown28 <bgcolor=0xd8d8ff>;
    u4 zero2C <bgcolor=0xd8d8ff>;
    u4 unknown30 <bgcolor=0xd8d8ff>;

    u4 comp_size;
    u4 uncomp_size;

    u4 zero3C <bgcolor=0xd8d8ff>;
    u4 zero40 <bgcolor=0xd8d8ff>;
    u4 unknown44 <bgcolor=0xd8d8ff>;
    u4 zero48 <bgcolor=0xd8d8ff>;

    Assert(zero06 == 0, "ARCHIVE zero06");
    Assert(zero08 == 0, "ARCHIVE zero08");
    Assert(zero0C == 0, "ARCHIVE zero0C");
    Assert(zero10 == 0, "ARCHIVE zero10");
    Assert(zero1C == 0, "ARCHIVE zero1C");
    Assert(zero2C == 0, "ARCHIVE zero2C");
    Assert(zero3C == 0, "ARCHIVE zero3C");
    Assert(zero40 == 0, "ARCHIVE zero40");
    Assert(zero48 == 0, "ARCHIVE zero48");
} ARCHIVE <optimize=false,read=read_ARCHIVE>;
string read_ARCHIVE(ARCHIVE &in) {
    string out;
    SPrintf(out, "\"%s\" %u %u", in.type, in.comp_size, in.uncomp_size);
    return out;
}

typedef struct {
    ARCHIVE a[h.archive_count];
} ARCHIVES <read=read_ARCHIVES>;
string read_ARCHIVES(ARCHIVES &in) {
    string out;
    SPrintf(out, "%u", h.archive_count);
    return out;
}

typedef struct {
    u4 name_offset;

    Assert(name_offset < h.names_length, "DIR name_offset too high");

    local quad o = FTell();
    FSeek(name_offset + full_names_offset);

    string name <bgcolor=0x60ffff>;

    FSeek(o);
} DIR <optimize=false,read=read_DIR>;
string read_DIR(DIR &in) {
    string out;
    SPrintf(out, "\"%s\"", in.name);
    return out;
}

typedef struct {
    DIR d[h.dir_count];
} DIRS <read=read_DIRS>;
string read_DIRS(DIRS &in) {
    string out;
    SPrintf(out, "%u", h.dir_count);
    return out;
}

typedef struct {
    u4 hash;
    u4 name_offset;

    u4 unknown08 <bgcolor=0xffd8ff>;
    u4 unknown0C <bgcolor=0xffd8ff>;
    u4 unknown10 <bgcolor=0xffd8ff>;

    Assert(name_offset < h.names_length, "PART name_offset too high");

    local quad o = FTell();
    FSeek(name_offset + full_names_offset);

    string name <bgcolor=0xff60ff>;

    FSeek(o);
} PART <optimize=false,read=read_PART>;
string read_PART(PART &in) {
    string out;
    SPrintf(out, "\"%s\" 0x%08x 0x%x 0x%x 0x%x", in.name, in.hash, in.unknown08, in.unknown0C, in.unknown10);
    return out;
}

typedef struct {
    PART p[h.part_count];
} PARTS <read=read_PARTS>;
string read_PARTS(PARTS &in) {
    string out;
    SPrintf(out, "%u", h.part_count);
    return out;
}

typedef struct {
    u4 unknown00 <bgcolor=0xffffd8>;

    u4 name_offset;

    u4 unknown08 <bgcolor=0xffffd8>;

    Assert(name_offset < h.names_length, "OTHER name_offset too high");

    local quad o = FTell();
    FSeek(name_offset + full_names_offset);

    string name <bgcolor=0xffff60>;

    FSeek(o);
} OTHER <optimize=false,read=read_OTHER>;
string read_OTHER(OTHER &in) {
    string out;
    SPrintf(out, "\"%s\" 0x%x 0x%08x", in.name, in.unknown00, in.unknown08);
    return out;
}

typedef struct {
    OTHER o[h.other_count];
} OTHERS <read=read_OTHERS>;
string read_OTHERS(OTHERS &in) {
    string out;
    SPrintf(out, "%u", h.other_count);
    return out;
}

typedef struct {
    u4 unknown00 <bgcolor=0xd8d8d8>;
    u4 unknown04 <bgcolor=0xd8d8d8>;
} HEADER3;


DisplayFormatHex();
LittleEndian();

local int i;

Assert(ReadString(0, 4) == "FRES", "Bad sig!");

local u4 full_names_offset = 0x90;

SetBackColor(0xb0b0b0);
HEADER h;

// skip main name table
FSeek(h.names_length + full_names_offset);

SetBackColor(0xffb0b0);
if (h.type_count) {
    TYPES t;
}

SetBackColor(0xb0ffb0);
if (h.file_count) {
    FILES f;
}

SetBackColor(0xb0b0ff);
if (h.archive_count) {
    ARCHIVES a;
}

SetBackColor(0xb0ffff);
if (h.dir_count) {
    DIRS d;
}

SetBackColor(0xffb0ff);
if (h.part_count) {
    PARTS p;
}

SetBackColor(0xffffb0);
if (h.other_count) {
    OTHERS o;
}

SetBackColor(0xb0b0b0);
HEADER3 h3;

Assert(ReadUShort() == 0x9c78, "bad zlib header");
