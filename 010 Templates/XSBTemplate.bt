//--------------------------------------
//--- 010 Editor v4.0.2 Binary Template
//
// File: XSBTemplate.bt
// Author: Andrew McRae
// Revision: 0.1
// Purpose: Parse XACT sound bank
//--------------------------------------

typedef uint64 u8;
typedef uint32 u4;
typedef uint16 u2;
typedef ubyte  u1;
typedef int64  s8;
typedef int32  s4;
typedef int16  s2;
typedef byte   s1;


typedef struct {
	SetBackColor(0xff90ff);
	u4 name_offset;
	s2 hash <format=decimal>;

	local int cur_pos = FTell();
	FSeek(name_offset);
	SetBackColor(0xffc0ff);
	string name;
	FSeek(cur_pos);
} NAME_HASH <optimize=false>;



typedef struct {
	char name[64];
} NAME <read=read_NAME,optimize=false>;

string read_NAME(NAME &in) {
	return in.name;
}


typedef struct {
	SetBackColor(0xb8b8b8);

	char signature[4];

	u2 content_version <format=decimal>;

	u2 header_version <format=decimal>;
	u2 crc;

	FILETIME last_modified;

	u1 platform;

	u2 num_simple_cue <format=decimal>;
	u2 num_complex_cue <format=decimal>;
	u2 num_unknown1 <format=decimal>;
	u2 num_cue_hash <format=decimal>;
	u1 num_wavebank <format=decimal>;
	u2 num_sound <format=decimal>;

	u4 cue_names_len;

	s4 off_simple_cue;
	s4 off_complex_cue;
	s4 off_cue_names;
	s4 off_unknown1;
	s4 off_variation;
	s4 off_transition;
	s4 off_wavebank_name;
	s4 off_cue_name_hash;
	s4 off_cue_name_table;
	s4 off_sound;

	NAME name;
} XSB_HEADER;


typedef struct {
	u4 sound_offset;
	u1 weight_min;
	u1 weight_max;
} VARIATION;


typedef struct {
	SetBackColor(0x90ff90);
	u2 count;
	enum <u1> {tORDERED=8, tORDERED_RANDOM, tRANDOM, tRANDOM_NOREP, tSHUFFLE} order_type: 4;
	u1 table_type: 4;
	u1 unknown;
	u1 unknown;
	u1 unknown;
	u1 unknown;
	u1 unknown;

	VARIATION t[count];
} XSB_VARIATION;


typedef struct {
	u1 stop_cue: 1;
	u1 stop_immediate: 1;
	u1 unknown_flags: 6;
	Assert(unknown_flags == 0);
} CLIP_EVENT_0;

typedef struct {
	u1 loop_play_release: 1;
	u1 pan_enable: 1;
	u1 pan_center: 1;
	u1 pan_new: 1;
	u1 unknown_flags: 4;
	u2 track;
	u1 wavebank;
	u1 loop_count <format=decimal>;
	u2 pan_angle <format=decimal>;
	u2 pan_arc <format=decimal>;
	Assert(unknown_flags == 0);
} CLIP_EVENT_1;


typedef struct {
	s2 pitch_min <format=decimal>;
	s2 pitch_max <format=decimal>;
	u1 vol_min;
	u1 vol_max;
	float freq_min;
	float freq_max;
	float q_min;
	float q_max;
	u1 vol_add: 1;
	u1 unknown: 1;
	u1 pitch_add: 1;
	u1 unknown: 1;
	u1 freq_add: 1;
	u1 unknown: 1;
	u1 q_add: 1;
	u1 unknown: 1;
	u1 pitch_new: 1;
	u1 vol_new: 1;
	u1 freq_new: 1;
	u1 q_new: 1;
	u1 pitch_var: 1;
	u1 vol_var: 1;
	u1 freq_var: 1;
	u1 q_var: 1;
} CLIP_EVENT_4;


typedef struct {
	u1 type;
	if (type == 0) {
		u1 add: 1;
		u1 random: 1;
		u1 value: 1;
		u1 unknown_flags: 5;
		u2 unknown;
		s2 min <format=decimal>;
		u2 unknown;
		s2 max <format=decimal>;
		u2 unknown;
		u2 unknown;
		u1 unknown;
	}
	else {
		s2 unknown <format=decimal>;
		s2 initial <format=decimal>;
		float slope;
		float delta;
		s2 seconds <format=decimal>;
	}
} CLIP_EVENT_7;


typedef struct {
	u1 type;
	if (type == 0) {
		u1 add: 1;
		u1 random: 1;
		u1 value: 1;
		u1 unknown_flags: 5;
		u2 unknown;
		s2 min <format=decimal>;
		u2 unknown;
		s2 max <format=decimal>;
		u2 unknown;
		u2 unknown;
		u1 unknown;
	}
	else {
		s2 unknown <format=decimal>;
		s2 initial <format=decimal>;
		float slope;
		float delta;
		s2 seconds <format=decimal>;
	}
} CLIP_EVENT_8;


typedef struct {
	u4 marker;
} CLIP_EVENT_9;


typedef struct {
	u2 repeats <format=decimal>;
	u2 frequency <format=decimal>;
} CLIP_EVENT_18;

typedef struct {
	SetBackColor(0xfff0a0);

	u4 event_type: 5;
	u4 timestamp: 16 <format=decimal>;
	u4 unknown: 11;
	u2 random_offset <format=decimal>;
	u1 unknown;

	switch (event_type) {
		case 0:
			CLIP_EVENT_0 e;
			break;
		case 1:
			CLIP_EVENT_1 e;
			break;
		case 4:
			CLIP_EVENT_1 e;
			CLIP_EVENT_4 e;
			break;
		case 7:
			CLIP_EVENT_7 e;
			break;
		case 8:
			CLIP_EVENT_8 e;
			break;
		case 9:
			CLIP_EVENT_9 e;
			break;
		case 18:
			CLIP_EVENT_9 e;
			CLIP_EVENT_18 e;
			break;
		default:
			break;
	}

} CLIP_EVENT <optimize=false>;

typedef struct {
	SetBackColor(0xfff0a0);

	u1 num_events;
//	Assert(num_events == 1);

	CLIP_EVENT events[num_events];
} SOUND_CLIP <optimize=false>;


typedef struct {
	SetBackColor(0xffc090);

	u1 volume;
	u4 off_clip;
	u2 filter_enable: 1;
	enum <u2> {fLOW, fBAND, fHIGH} filter_type: 2;
	u2 filter_q: 13 <format=decimal>;
	u2 filter_freq <format=decimal>;

	local int cur_pos = FTell();
	FSeek(off_clip);
	SOUND_CLIP clip;
	FSeek(cur_pos);
} XSB_CLIP <optimize=false>;

typedef struct {
	u1 var_num;
	u4 var_offset[var_num];
	cur_size += 1 + 4 * var_num;
} VAR_OFFSETS <optimize=false>;


typedef struct {
	SetBackColor(0xff9090);

	local int cur_pos = FTell();

	u1 has_clips: 1;
	u1 rpc_count: 3;
	u1 has_dsp: 1;
	u1 unknown_flags: 3;
	Assert(unknown_flags == 0, "Unknown flags in XSB_SOUND");
	u2 category;
	u1 volume;
	s2 pitch <format=decimal>;
	u1 priority;
	u2 entry_len;

	if (has_clips) {
		u1 num_clip;
	}
	else {
		u2 track;
		u1 wavebank;
	}

	local int cur_size = 0;
	if (rpc_count) {
		local int rpc_pos = FTell();
		SetBackColor(0xff90c0);
		u2 rpc_extra;
		cur_size = 2;
		VAR_OFFSETS rpc[rpc_count];
		//Assert(rpc_extra == cur_size);
		FSeek(rpc_pos + rpc_extra);
	}

	if (has_dsp) {
		local int dsp_pos = FTell();
		SetBackColor(0xffa0f0);
		u2 dsp_extra;
		cur_size = 2;
		VAR_OFFSETS dsp;
		Assert(dsp_extra == cur_size);
		FSeek(dsp_pos + dsp_extra);
	}

	if (has_clips) {
		XSB_CLIP clips[num_clip];
	}

	Assert(FTell() <= (cur_pos + entry_len));
	FSeek(cur_pos + entry_len);
} XSB_SOUND <optimize=false>;


typedef struct (int index) {
	local int name_index = index;
	SetBackColor(0x90ff90);

	u1 flags;
	s4 sound_offset;
} XSB_SIMPLE_CUE <read=read_XSB_SIMPLE_CUE>;

string read_XSB_SIMPLE_CUE(XSB_SIMPLE_CUE &in) {
	if (h.cue_names_len) {
		return cn[in.name_index].name;
	}
	else {
		return "";
	}
}


typedef struct (int index) {
	local int name_index = index;
	SetBackColor(0x9090ff);

	u1 has_variation: 1;
	u1 has_transition: 1;
	u1 unknown_flags: 6;
	Assert(unknown_flags == 0);

	s4 off_variation;
	s4 off_transition;

	u1 instance_limit <format=decimal>;
	u2 fade_in <format=decimal>;
	u2 fade_out <format=decimal>;
	enum <u1> {fLINEAR, fLOG, fEQL_POW} fade_type: 3;
	enum <u1> {iFAIL_TO_PLAY, iQUEUE, iREPLACE_OLDEST, iREPLACE_QUIETEST, iREPLACE_LOWEST} inst_flags: 5;
	
	local int cur_pos = FTell();

	if (has_variation && off_variation >= 0) {
		FSeek(off_variation);
		XSB_VARIATION v;
		FSeek(cur_pos);
	}
} XSB_COMPLEX_CUE <read=read_XSB_COMPLEX_CUE>;

string read_XSB_COMPLEX_CUE(XSB_COMPLEX_CUE &in) {
	if (h.cue_names_len) {
		return cn[in.name_index].name;
	}
	else {
		return "";
	}
}


DisplayFormatHex();
LittleEndian();
BitfieldRightToLeft();

local uint sig;
sig = ReadInt(0);

if (sig == 0x5344424B) {
	Warning("BigEndian");
	BigEndian();
	BitfieldRightToLeft();
	sig = ReadInt(0);
}

if (sig != 0x4B424453) {
	Printf("Incorrect signature\n");
	Warning("Incorrect signature");
	return -1;
}


XSB_HEADER h;

local int i;

if (h.num_wavebank && h.off_wavebank_name >= 0) {
	FSeek(h.off_wavebank_name);
	SetBackColor(0xd8d8d8);
	NAME wn[h.num_wavebank];
}

if (h.num_sound && h.off_sound >= 0) {
	FSeek(h.off_sound);
	XSB_SOUND s[h.num_sound];
}

local int cur_name_index = 0;
if (h.num_simple_cue && h.off_simple_cue >= 0) {
	FSeek(h.off_simple_cue);
	for (i = 0; i < h.num_simple_cue; i++, cur_name_index++) {
		XSB_SIMPLE_CUE cs(cur_name_index);
	}
}

if (h.num_complex_cue && h.off_complex_cue >= 0) {
	FSeek(h.off_complex_cue);
	for (i = 0; i < h.num_complex_cue; i++, cur_name_index++) {
		XSB_COMPLEX_CUE cc(cur_name_index);
	}
}

if (h.num_cue_hash && h.off_cue_name_hash >= 0) {
	FSeek(h.off_cue_name_hash);
	SetBackColor(0xc0c0c0);
	s2 ch[h.num_cue_hash] <format=decimal>;
}

if (h.cue_names_len && h.off_cue_name_table >= 0) {
	FSeek(h.off_cue_name_table);
	NAME_HASH cn[h.num_simple_cue + h.num_complex_cue];
}
