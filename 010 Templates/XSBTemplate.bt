//--------------------------------------
//--- 010 Editor v4.0.2 Binary Template
//
// File: XSBTemplate.bt
// Author: Andrew McRae
// Revision: 0.1
// Purpose: Parse XACT sound bank
//--------------------------------------

typedef uint64 u8;
typedef uint32 u4;
typedef uint16 u2;
typedef ubyte  u1;
typedef int64  s8;
typedef int32  s4;
typedef int16  s2;
typedef byte   s1;


typedef struct {
	SetBackColor(0xff90ff);
	u4 name_offset;
	s2 hash <format=decimal>;

	local int cur_pos = FTell();
	FSeek(name_offset);
	SetBackColor(0xffc0ff);
	string name;
	FSeek(cur_pos);
} NAME_HASH <optimize=false>;



typedef struct {
	char name[64];	
} NAME <read=read_NAME,optimize=false>;

string read_NAME(NAME &in) {
	return in.name;
}


typedef struct {
	SetBackColor(0xb8b8b8);

	char signature[4];

	u2 content_version <format=decimal>;

	u2 header_version <format=decimal>;
	u2 crc;

	FILETIME last_modified;

	u1 platform;

	u2 num_simple_cue <format=decimal>;
	u2 num_complex_cue <format=decimal>;
	u2 num_unknown1 <format=decimal>;
	u2 num_cue_hash <format=decimal>;
	u1 num_wavebank <format=decimal>;
	u2 num_sound <format=decimal>;

	u4 cue_names_len;

	s4 off_simple_cue;
	s4 off_complex_cue;
	s4 off_cue_names;
	s4 off_unknown1;
	s4 off_variation;
	s4 off_transition;
	s4 off_wavebank_name;
	s4 off_cue_name_hash;
	s4 off_cue_name_table;
	s4 off_sound;

	NAME name;
} XSB_HEADER;


typedef struct {
	u4 unknown;
	u2 track;
	u1 wavebank;
	u1 unknown;
	u2 unknown;
	u2 unknown;
} CLIP_EVENT_1 <optimize=false>;


typedef struct {
	SetBackColor(0xfff0a0);

	u4 event_info;
	
	switch (event_info & 0x1f) {
		case 1:
			CLIP_EVENT_1 event;
			break;
		default:
			break;
	}

} CLIP_EVENT <optimize=false>;

typedef struct {
	SetBackColor(0xfff0a0);
	
	u1 num_events;
	Assert(num_events == 1);

	CLIP_EVENT events[num_events];
} SOUND_CLIP <optimize=false>;


typedef struct {
	SetBackColor(0xffc090);

	u1 unknown;
	u4 off_clip;
	u4 unknown;

	local int cur_pos = FTell();
	FSeek(off_clip);
	SOUND_CLIP clip;
	FSeek(cur_pos);
} XSB_CLIP <optimize=false>;


typedef struct {
	SetBackColor(0xff9090);

	local int cur_pos = FTell();

	u1 flags;
	u2 category;
	u1 unknown;
	u2 volume;
	u1 unknown;
	u2 entry_len;

	if (flags & 1) {
		u1 num_clip;
	}
	else {
		u2 track;
		u1 wavebank;
	}

	if (flags & 0xe) {
		SetBackColor(0xff90c0);
		u2 rpc_extra;
		u1 rpc[rpc_extra - 2];
	}

	if (flags & 16) {
		SetBackColor(0xffa0f0);
		u2 dsp_extra;
		u1 dsp_num;
		u4 dsp_param[dsp_num];
		Assert(dsp_extra == 2 + 1 + dsp_num * 4);
	}

	if (flags & 1) {
		XSB_CLIP clips[num_clip];
	}

	Assert(FTell() <= (cur_pos + entry_len));
	FSeek(cur_pos + entry_len);
} XSB_SOUND <optimize=false>;


typedef struct (int index) {
	local int name_index = index;
	SetBackColor(0x90ff90);

	u1 flags;
	u4 sound_offset;
} XSB_SIMPLE_CUE <read=read_XSB_SIMPLE_CUE>;

string read_XSB_SIMPLE_CUE(XSB_SIMPLE_CUE &in) {
	return cn[in.name_index].name;
}


typedef struct (int index) {
	local int name_index = index;
	SetBackColor(0x9090ff);

	u1 flags;
	u4 off_variation;
	u4 off_transition;

	u4 unknown;
	u1 unknown;
	u1 unknown;
} XSB_COMPLEX_CUE <read=read_XSB_COMPLEX_CUE>;

string read_XSB_COMPLEX_CUE(XSB_COMPLEX_CUE &in) {
	return cn[in.name_index].name;
}


DisplayFormatHex();
LittleEndian();
BitfieldRightToLeft();

local uint sig;
sig = ReadInt(0);

if (sig == 0x5344424B) {
	Warning("BigEndian");
	BigEndian();
	BitfieldRightToLeft();
	sig = ReadInt(0);
}

if (sig != 0x4B424453) {
	Printf("Incorrect signature\n");
	Warning("Incorrect signature");
	return -1;
}


XSB_HEADER h;

local int i;

if (h.num_wavebank) {
	FSeek(h.off_wavebank_name);
	SetBackColor(0xd8d8d8);
	NAME wn[h.num_wavebank];
}

if (h.num_sound) {
	FSeek(h.off_sound);
	XSB_SOUND s[h.num_sound];
}

local int cur_name_index = 0;
if (h.num_simple_cue) {
	FSeek(h.off_simple_cue);
	for (i = 0; i < h.num_simple_cue; i++, cur_name_index++) {
		XSB_SIMPLE_CUE cs(cur_name_index);
	}
}

if (h.num_complex_cue) {
	FSeek(h.off_complex_cue);
	for (i = 0; i < h.num_complex_cue; i++, cur_name_index++) {
		XSB_COMPLEX_CUE cc(cur_name_index);
	}
}

if (h.num_cue_hash) {
	FSeek(h.off_cue_name_hash);
	SetBackColor(0xc0c0c0);
	s2 ch[h.num_cue_hash] <format=decimal,hidden=true>;
}

if (h.num_simple_cue + h.num_complex_cue) {
	FSeek(h.off_cue_name_table);
	NAME_HASH cn[h.num_simple_cue + h.num_complex_cue] <hidden=true>;
}
