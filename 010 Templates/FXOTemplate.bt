//--------------------------------------
//--- 010 Editor v3.2.2 Binary Template
//
// File: FXOTemplate.bt
// Author: Andrew McRae
// Revision: 0.1
// Purpose: binary DX FX 4/5 files
//--------------------------------------

DisplayFormatHex();

typedef uint64 u8;
typedef uint32 u4;
typedef uint16 u2;
typedef ubyte  u1;
typedef int64  s8;
typedef int32  s4;
typedef int16  s2;
typedef byte   s1;

local quad _data_start;

string read_sig(u4 &in) {
    local string out;
    local string ver;
    switch(in & 0xffff) {
        case 0x0901:
            ver = "fx_2_0";
            break;
        case 0x1001:
            ver = "fx_4_0";
            break;
        case 0x1011:
            ver = "fx_4_1";
            break;
        case 0x2001:
            ver = "fx_5_0";
            break;
        default:
            SPrintf(ver, "(%04X)", in & 0xffff);
            break;
    }
    SPrintf(out, "%s %s", IsBigEndian() ? "BE" : "LE", ver);
    return out;
}

typedef struct {
    u4 sig;
    u4 data_offset;
} HEADER <read=read_HEADER>;
string read_HEADER(HEADER &in) {
    return read_sig(in.sig);
}

typedef struct {
    local quad _pos, _padding;

    u4 offset;

    _pos = FTell();
    FSeek(_data_start + offset);

    SetBackColor(0xffffc0);
    u4 size;

    if (size) {
        SetBackColor(0xffffa0);
        char n[size];

        _padding = 4 - (FTell() & 3);
        if (_padding > 0 && padding < 4) {
            SetBackColor(0xffffff);
            u1 _p[_padding] <hidden=true>;
        }
    } else {
        local string n = "";
    }
    FSeek(_pos);
} D3DX_NAME <read=read_D3DX_NAME,optimize=false>;
string read_D3DX_NAME(D3DX_NAME &in) {
    local string out;
    SPrintf(out, "'%s'", in.n);
    return out;
}

typedef struct {
    local quad _pos;

    u4 typedef_offset;
    u4 value_offset;

    _pos = FTell();
    FSeek(_data_start + typedef_offset);

    SetBackColor(0xc0c0ff);
    u4 type;
    u4 class;
    D3DX_NAME name;
    D3DX_NAME semantic;
    u4 element_count <format=decimal>;

    FSeek(_data_start + value_offset);

    FSeek(_pos);
} D3DX_EFFECT_VALUE <read=read_D3DX_EFFECT_VALUE,optimize=false>;
string read_D3DX_EFFECT_VALUE(D3DX_EFFECT_VALUE &in) {
    local string out;
    SPrintf(out, "'%s'", in.name.n);
    return out;
}

typedef struct {
    D3DX_EFFECT_VALUE value;
    u4 flags;
    u4 annotation_count <format=decimal>;

    if (annotation_count) {
        D3DX_EFFECT_VALUE a[annotation_count];
    }
} D3DX_PARAMETER <read=read_D3DX_PARAMETER,optimize=false>;
string read_D3DX_PARAMETER(D3DX_PARAMETER &in) {
    local string out;
    SPrintf(out, "'%s'", in.value.name.n);
    return out;
}

typedef struct {
    u4 operation;
    s4 index <format=decimal>;
    D3DX_EFFECT_VALUE value;
} D3DX_STATE <optimize=false>;

typedef struct {
    D3DX_NAME name;
    u4 annotation_count <format=decimal>;
    u4 state_count <format=decimal>;

    if (annotation_count) {
        D3DX_EFFECT_VALUE a[annotation_count];
    }

    if (state_count) {
        D3DX_STATE s[state_count];
    }
} D3DX_PASS <read=read_D3DX_PASS,optimize=false>;
string read_D3DX_PASS(D3DX_PASS &in) {
    local string out;
    SPrintf(out, "'%s'", in.name.n);
    return out;
}

typedef struct {
    local int i;

    D3DX_NAME name;
    u4 annotation_count <format=decimal>;
    u4 pass_count <format=decimal>;

    if (annotation_count) {
        D3DX_EFFECT_VALUE a[annotation_count];
    }

    if (pass_count) {
        D3DX_PASS p[pass_count];
    }
} D3DX_TECHNIQUE <read=read_D3DX_TECHNIQUE,optimize=false>;
string read_D3DX_TECHNIQUE(D3DX_TECHNIQUE &in) {
    local string out;
    SPrintf(out, "'%s'", in.name.n);
    return out;
}

typedef struct {
    s4 index <format=decimal>;
    u4 size;
    if (size) {
        SetBackColor(0xb0ffb0);
        u1 data[size];
    }
} D3DX_SMALL <optimize=false>;

typedef struct {
    s4 technique_index <format=decimal>;
    s4 index <format=decimal>;
    s4 element_index <format=decimal>;
    s4 state_index <format=decimal>;
    u4 usage;
    u4 size;
    if (size) {
        SetBackColor(0xb0ffb0);
        u1 data[size];
    }
} D3DX_LARGE <optimize=false>;

typedef struct {
    local int i, padding;

    u4 parameter_count <format=decimal>;
    u4 technique_count <format=decimal>;
    u4 unknown_count <format=decimal>;
    u4 object_count <format=decimal>;

    if (parameter_count) {
        D3DX_PARAMETER p[parameter_count];
    }

    if (technique_count) {
        D3DX_TECHNIQUE t[technique_count];
    }

    u4 small_count <format=decimal>;
    u4 large_count <format=decimal>;

    if (small_count) {
        SetBackColor(0xd0ffd0);
        D3DX_SMALL s[small_count];
    }

    for (i = 0; i < large_count; i++) {
        SetBackColor(0xd0ffd0);
        D3DX_LARGE r;

        padding = 4 - (FTell() & 3);
        if (padding > 0 && padding < 4) {
            SetBackColor(0xffffff);
            u1 _p[padding] <hidden=true>;
        }
    }
} D3DX_EFFECT <optimize=false>;

local u4 _sig, _ver;
LittleEndian();
_sig = ReadUInt(0);

if ((_sig & 0xffff0000) == 0xfeff0000) {
    LittleEndian();
} else if ((_sig & 0xffff) == 0xfffe) {
    BigEndian();
    _sig = ReadUInt(0);
    Warning("BigEndian");
} else {
    Warning("Bad sig!");
    Printf("Bad sig!\n");
    return -1;
}

_ver = _sig & 0xffff;
if (_ver > 0x0901) {
    Warning("Unsupported version!");
    Printf("Unsupported version! %04X\n", _ver);
    return -1;
}

SetBackColor(0xc0c0c0);
HEADER h;

SetBackColor(0xf0f0f0);
_data_start = FTell();
if (h.data_offset) {
    u1 d[h.data_offset];
}

SetBackColor(0xffd0d0);
D3DX_EFFECT e;
